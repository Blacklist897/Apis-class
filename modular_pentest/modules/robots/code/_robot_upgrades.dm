/*
		Replaces "code\modules\mob\living\silicon\robot\robot_upgrades.dm"

		Purpose of modularization:
			The purpose of the modularized code is primarily to prevent updates being pushed by shiptest from causing
			conflict errors in the future. Shiptest loves to use single letter variables and non descriptive defines
			which make reading the code more difficult, and lead to various problems.

			Along with this, the code contained here is being refactored to be much more in line with TG Station,
			which will allow us to pull from TG Station, or various forks, for new updates and features without having to
			recode everything from scratch.

			Unfortunately, due to how many parts of the code are outdated, this is not a 1:1 copy of TG code. Eventually
			it would be best to update the system to be more in line, yet that would cause a much larger refactor of code
			across much more than the robot files.

			- Ossa


		Code Contained Here:
			The code contained within this file is for cyborg upgrade modules and their functionality
			This particular file is for general purpose modules, and the various procs being used.


		Individual loadouts, toolsets and Modules are located in their respective model files:

		Clown Cynorg Upgrades: clown_borg.dm
		Default Cyborg Upgrades: default_borg.dm
		Engineering Cyborg Upgrades: engi_borg.dm
		Janitor Cyborg Upgrades: jani_borg.dm
		Medical Cyborg Upgrades: med_borg.dm
		Miner Cyborg Upgrades: miner_borg.dm
		Ninja Cyborg Upgrades: ninja_borg.dm
		Peacekeeper Cyborg Upgrades: peace_borg.dm
		Science Cyborg Upgrades: science_borg.dm
		Security Cyborg Upgrades: sec_borg.dm
		Service Cyborg Upgrades: serv_borg.dm
		Syndicate Cyborg Upgeades: synd_borg.dm
*/

/obj/item/borg/upgrade
	name = "borg upgrade module."
	desc = "Protected by FRM."
	icon = 'icons/obj/module.dmi'
	icon_state = "cyborg_upgrade"
	w_class = WEIGHT_CLASS_SMALL
	var/locked = FALSE
	var/installed = 0
	var/require_module = 0
	var/list/model_type = null
	// if true, is not stored in the robot to be ejected
	// if module is reset
	var/one_use = FALSE

/obj/item/borg/upgrade/proc/action(mob/living/silicon/robot/R, user = usr)
	if(R.stat == DEAD)
		to_chat(user, "<span class='warning'>[src] will not function on a deceased cyborg!</span>")
		return FALSE
	if(model_type && !is_type_in_list(R.module, model_type))
		to_chat(R, "<span class='alert'>Upgrade mounting error! No suitable hardpoint detected.</span>")
		to_chat(user, "<span class='warning'>There's no mounting point for the module!</span>")
		return FALSE
	return TRUE

/obj/item/borg/upgrade/proc/deactivate(mob/living/silicon/robot/R, user = usr)
	if (!(src in R.upgrades))
		return FALSE
	return TRUE
//
// RENAME - BOARD AND CODE
//

/obj/item/borg/upgrade/rename
	name = "cyborg reclassification board"
	desc = "Used to rename a cyborg."
	icon_state = "cyborg_upgrade1"
	var/heldname = ""
	one_use = TRUE

/obj/item/borg/upgrade/rename/attack_self(mob/user)
	heldname = sanitize_name(stripped_input(user, "Enter new robot name", "Cyborg Reclassification", heldname, MAX_NAME_LEN))

/obj/item/borg/upgrade/rename/action(mob/living/silicon/robot/R)
	. = ..()
	if(.)
		var/oldname = R.real_name
		R.custom_name = heldname
		R.updatename()
		if(oldname == R.real_name)
			R.notify_ai(RENAME, oldname, R.real_name)

//
// RESTART - BOARD AND CODE
//

/obj/item/borg/upgrade/restart
	name = "cyborg emergency reboot module"
	desc = "Used to force a reboot of a disabled-but-repaired cyborg, bringing it back online."
	icon_state = "module_general"
	one_use = TRUE

/obj/item/borg/upgrade/restart/action(mob/living/silicon/robot/R, user = usr)
	if(R.health < 0)
		to_chat(user, "<span class='warning'>You have to repair the cyborg before using this module!</span>")
		return FALSE

	if(R.mind)
		R.mind.grab_ghost()
		playsound(loc, 'sound/voice/liveagain.ogg', 75, TRUE)

	R.revive(full_heal = FALSE, admin_revive = FALSE)
	R.logevent("WARN -- System recovered from unexpected shutdown.")
	R.logevent("System brought online.")

//
// ION THRUSTERS - BOARD AND CODE
//

/obj/item/borg/upgrade/thrusters
	name = "ion thruster upgrade"
	desc = "An energy-operated thruster system for cyborgs."
	icon_state = "module_general"

/obj/item/borg/upgrade/thrusters/action(mob/living/silicon/robot/R, user = usr)
	. = ..()
	if(.)
		if(R.ionpulse)
			to_chat(user, "<span class='warning'>This unit already has ion thrusters installed!</span>")
			return FALSE

		R.ionpulse = TRUE
		R.toggle_ionpulse() //Enabled by default

/obj/item/borg/upgrade/thrusters/deactivate(mob/living/silicon/robot/R, user = usr)
	. = ..()
	if (.)
		R.ionpulse = FALSE

//
// SELF REPAIR - BOARD AND CODE
//

/obj/item/borg/upgrade/selfrepair
	name = "self-repair module"
	desc = "This module will repair the cyborg over time."
	icon_state = "module_general"
	require_module = 1
	var/repair_amount = -1
	var/repair_tick = 1
	var/msg_cooldown = 0
	var/on = FALSE
	var/powercost = 10
	var/datum/action/toggle_action

/obj/item/borg/upgrade/selfrepair/action(mob/living/silicon/robot/R, user = usr)
	. = ..()
	if(.)
		var/obj/item/borg/upgrade/selfrepair/U = locate() in R
		if(U)
			to_chat(user, "<span class='warning'>This unit is already equipped with a self-repair module!</span>")
			return FALSE

		icon_state = "selfrepair_off"
		toggle_action = new /datum/action/item_action/toggle(src)
		toggle_action.Grant(R)

/obj/item/borg/upgrade/selfrepair/deactivate(mob/living/silicon/robot/R, user = usr)
	. = ..()
	if (.)
		toggle_action.Remove(R)
		QDEL_NULL(toggle_action)
		deactivate_sr()

/obj/item/borg/upgrade/selfrepair/ui_action_click()
	if(on)
		to_chat(toggle_action.owner, "<span class='notice'>You deactivate the self-repair module.</span>")
		deactivate_sr()
	else
		to_chat(toggle_action.owner, "<span class='notice'>You activate the self-repair module.</span>")
		activate_sr()

/obj/item/borg/upgrade/selfrepair/update_icon_state()
	if(toggle_action)
		icon_state = "selfrepair_[on ? "on" : "off"]"
	else
		icon_state = "module_general"
	return ..()

/obj/item/borg/upgrade/selfrepair/proc/activate_sr()
	START_PROCESSING(SSobj, src)
	on = TRUE
	update_appearance()

/obj/item/borg/upgrade/selfrepair/proc/deactivate_sr()
	STOP_PROCESSING(SSobj, src)
	on = FALSE
	update_appearance()

/obj/item/borg/upgrade/selfrepair/process()
	if(!repair_tick)
		repair_tick = 1
		return

	var/mob/living/silicon/robot/cyborg = toggle_action.owner

	if(istype(cyborg) && (cyborg.stat != DEAD) && on)
		if(!cyborg.cell)
			to_chat(cyborg, "<span class='alert'>Self-repair module deactivated. Please insert power cell.</span>")
			deactivate_sr()
			return

		if(cyborg.cell.charge < powercost * 2)
			to_chat(cyborg, "<span class='alert'>Self-repair module deactivated. Please recharge.</span>")
			deactivate_sr()
			return

		if(cyborg.health < cyborg.maxHealth)
			if(cyborg.health < 0)
				repair_amount = -2.5
				powercost = 30
			else
				repair_amount = -1
				powercost = 10
			cyborg.adjustBruteLoss(repair_amount)
			cyborg.adjustFireLoss(repair_amount)
			cyborg.updatehealth()
			cyborg.cell.use(powercost)
		else
			cyborg.cell.use(5)
		repair_tick = 0

		if((world.time - 2000) > msg_cooldown)
			var/msgmode = "standby"
			if(cyborg.health < 0)
				msgmode = "critical"
			else if(cyborg.health < cyborg.maxHealth)
				msgmode = "normal"
			to_chat(cyborg, "<span class='notice'>Self-repair is active in <span class='boldnotice'>[msgmode]</span> mode.</span>")
			msg_cooldown = world.time
	else
		deactivate_sr()

//
// EXPAND - BOARD AND CODE
//

/obj/item/borg/upgrade/expand
	name = "borg expander"
	desc = "A cyborg resizer, it makes a cyborg huge."
	icon_state = "module_general"

/obj/item/borg/upgrade/expand/action(mob/living/silicon/robot/R, user = usr)
	. = ..()
	if(.)

		if(R.hasExpanded)
			to_chat(usr, "<span class='warning'>This unit already has an expand module installed!</span>")
			return FALSE

		R.notransform = TRUE
		var/prev_lockcharge = R.lockcharge
		R.SetLockdown(1)
		R.set_anchored(TRUE)
		var/datum/effect_system/smoke_spread/smoke = new
		smoke.set_up(1, R.loc)
		smoke.start()
		sleep(2)
		for(var/i in 1 to 4)
			playsound(R, pick('sound/items/drill_use.ogg', 'sound/items/jaws_cut.ogg', 'sound/items/jaws_pry.ogg', 'sound/items/welder.ogg', 'sound/items/ratchet.ogg'), 80, TRUE, -1)
			sleep(12)
		if(!prev_lockcharge)
			R.SetLockdown(0)
		R.set_anchored(FALSE)
		R.notransform = FALSE
		R.resize = 2
		R.hasExpanded = TRUE
		R.update_transform()

/obj/item/borg/upgrade/expand/deactivate(mob/living/silicon/robot/R, user = usr)
	. = ..()
	if (.)
		if (R.hasExpanded)
			R.hasExpanded = FALSE
			R.resize = 0.5
			R.update_transform()

//
// BORIS - BOARD AND CODE
//

/obj/item/borg/upgrade/ai
	name = "B.O.R.I.S. module"
	desc = "Bluespace Optimized Remote Intelligence Synchronization. An uplink device which takes the place of an MMI in cyborg endoskeletons, creating a robotic shell controlled by an AI."
	icon = 'icons/obj/module.dmi'
	icon_state = "boris"

/obj/item/borg/upgrade/ai/action(mob/living/silicon/robot/R, user = usr)
	. = ..()
	if(.)
		if(R.shell)
			to_chat(user, "<span class='warning'>This unit is already an AI shell!</span>")
			return FALSE
		if(R.key) //You cannot replace a player unless the key is completely removed.
			to_chat(user, "<span class='warning'>Intelligence patterns detected in this [R.braintype]. Aborting.</span>")
			return FALSE

		R.make_shell(src)

/obj/item/borg/upgrade/ai/deactivate(mob/living/silicon/robot/R, user = usr)
	. = ..()
	if (.)
		if(R.shell)
			R.undeploy()
			R.notify_ai(DISCONNECT)

//
// SHIP ACCESS CHIP - BOARD AND CODE
//

/obj/item/borg/upgrade/ship_access_chip
	name = "silicon ship access chip"
	desc = "A module that grants cyborgs and AI access to the ship this was printed from."
	icon = 'icons/obj/module.dmi'
	icon_state = "card_mod"
	var/datum/overmap/ship/controlled/ship

/obj/item/borg/upgrade/ship_access_chip/examine(mob/user)
	. = ..()
	. += "The chip has access for [ship.name] installed."

/obj/item/borg/upgrade/ship_access_chip/action(mob/living/silicon/robot/robot, user = usr)
	. = ..()
	if(.)
		var/obj/item/borg/upgrade/ship_access_chip/chip = locate() in robot.module
		if(chip)
			to_chat(user, "<span class='warning'>[robot] already has access to [ship.name]!</span>")
			return FALSE

		chip = new(robot.module)
		robot.module.basic_modules += chip
		robot.module.add_module(chip, FALSE, TRUE)
		robot.add_ship_access(ship)

/obj/item/borg/upgrade/ship_access_chip/deactivate(mob/living/silicon/robot/robot, user = usr)
	. = ..()
	if (.)
		var/obj/item/borg/upgrade/ship_access_chip/chip = locate() in robot.module
		if (chip)
			robot.module.remove_module(chip, TRUE)
		robot.remove_ship_access(ship)

/obj/item/borg/upgrade/ship_access_chip/afterattack(mob/living/silicon/ai/ai, mob/user, proximity)
	. = ..()
	if(!proximity)
		return
	if(!istype(ai))
		return
	if(ai.has_ship_access(ship))
		to_chat(user, "<span class='warning'>[ai] already has access to [ship.name]!</span>")
		return

	to_chat(ai, "<span class='notice'>[user] has upgraded you with access to [ship.name].</span>")
	ai.add_ship_access(ship)
	to_chat(user, "<span class='notice'>You upgrade [ai]. [src] is consumed in the process.</span>")
	qdel(src)
